package org.jni.example.decorations;


import javafx.beans.property.*;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Parent;
import javafx.scene.control.Label;
import javafx.scene.image.ImageView;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
import org.jni.example.Assets;
import xss.it.javafx.control.ActionButtons;
import xss.it.javafx.util.ColorUtil;
import xss.it.javafx.util.HitSpot;

import java.util.List;

/**
 * @author XDSSWAR
 * Created on 06/12/2023
 */
public final class NormalDecoration extends AnchorPane {
    private final HBox header;
    private final ImageView icon;
    private final Label title;
    private final ActionButtons actionBox;
    private final StackPane content;
    private static final String STYLE_SHEET = Assets.load("/org/jni/example/normal-decoration.css").toExternalForm();
    private final Stage stage;
    private final BooleanProperty titleCentered=new SimpleBooleanProperty(false);
    private final IntegerProperty titleBarHeight=new SimpleIntegerProperty(30);
    private final ObjectProperty<Parent> decorationContent=new SimpleObjectProperty<>();
    private final ObservableList<String> styles= FXCollections.observableArrayList();

    /**
     * Constructs a new NormalDecoration object for the specified DecoratedStage.
     *
     * @param stage the DecoratedStage to associate with the NormalDecoration
     */
    public NormalDecoration(Stage stage) {
        this.stage=stage;
        header = new HBox();
        icon = new ImageView();
        title = new Label();
        actionBox = new ActionButtons();
        content = new StackPane();

        initialize();
    }


    /**
     * Method auto-generated by 2Code Converter.
     */
    private void initialize() {
        getStylesheets().add(STYLE_SHEET);

        AnchorPane.setLeftAnchor(header, 0.0);
        AnchorPane.setRightAnchor(header, 0.0);
        AnchorPane.setTopAnchor(header, 0.0);
        header.setAlignment(Pos.CENTER);
        header.setPrefHeight(titleBarHeight.getValue());
        header.setMinHeight(30d);
        header.getStyleClass().add("title-bar");

        icon.setFitHeight(20.0);
        icon.setFitWidth(20.0);
        icon.setPickOnBounds(true);
        icon.setPreserveRatio(true);
        HBox.setMargin(icon, new Insets(0.0, 0.0, 0.0, 5.0));
        if (stage.getIcons().size()>0) {
            icon.setImage(stage.getIcons().get(stage.getIcons().size() - 1));
        }

        title.setPrefWidth(10000d);
        title.getStyleClass().add("title");
        title.setMinWidth(0);
        title.setText(stage.getTitle());
        HBox.setMargin(title, new Insets(0.0, 0.0, 0.0, 5.0));

        actionBox.setAlignment(Pos.CENTER_RIGHT);
        actionBox.setMinWidth(150.0);
        actionBox.setPrefWidth(150.0);


        actionBox.setMaximizeShape(stage.isMaximized());

        AnchorPane.setBottomAnchor(content, 0.0);
        AnchorPane.setLeftAnchor(content, 0.0);
        AnchorPane.setRightAnchor(content, 0.0);
        AnchorPane.setTopAnchor(content, 30.0);
        content.setCache(false);

        header.getChildren().add(icon);
        header.getChildren().add(title);

        header.getChildren().add(actionBox);

        getChildren().add(content);
        getChildren().add(header);

        /*
         * Init events
         */
        initEvents();
    }

    /**
     * Initialize Events
     */
    private void initEvents() {
        stage.maximizedProperty().addListener((observable, oldValue, max) -> actionBox.setMaximizeShape(max));
        actionBox.setOnMinimizeButtonClick(event -> stage.setIconified(true));
        actionBox.setOnMaximizeButtonClick(event -> stage.setMaximized(!stage.isMaximized()));
        actionBox.setOnCloseButtonClick(event -> stage.close());
        header.backgroundProperty().addListener((observable, oldValue, bg) -> processBg(bg));
        processBg(header.getBackground());

        titleBarHeight.addListener((observable, oldValue, height) -> {
            header.setPrefHeight(height.doubleValue());
            AnchorPane.setTopAnchor(content,height.doubleValue());
        });

        titleCentered.addListener((observable, oldValue, newValue) -> handleTitleAlignment(newValue));
        handleTitleAlignment(titleCentered.get());

        decorationContent.addListener((observable, oldValue, root) -> {
            if (root!=null){
                getStylesheets().removeAll(styles);
                styles.clear();
                styles.setAll(root.getStylesheets());
                content.getChildren().clear();
                attach(root);
                getStylesheets().addAll(styles);

                //If you have css issues , comment this line below
                root.getStylesheets().clear();
                content.getChildren().add(root);
            }
        });
    }



    /**
     * Sets the content of the container.
     *
     * @param root The Parent object representing the content to be set.
     */
    public void setContent(Parent root){
        decorationContent.set(root);
    }

    /**
     * Attaches the content to the parent Region and keeps its size in sync with the content's size.
     *
     * @param parent The parent node to which the content will be attached.
     */
    private void attach(Parent parent){
        if (parent instanceof Region reg) {
            content.widthProperty().addListener((observable, oldValue, newValue)
                    -> reg.setPrefWidth(newValue.doubleValue()));

            content.heightProperty().addListener((observable, oldValue, newValue)
                    -> reg.setPrefHeight(newValue.doubleValue()));
        }
    }

    /**
     * Sets whether the title text should be centered.
     *
     * @param center true to center the title text, false otherwise.
     */
    public void centerTitle(boolean center){
        titleCentered.set(center);
    }

    /**
     * Returns a boolean indicating whether the title is centered.
     *
     * @return true if the title is centered, false otherwise
     */
    public boolean isTitleCentered() {
        return titleCentered.get();
    }

    /**
     * Returns a read-only boolean property representing the centered state of the title.
     *
     * @return the read-only boolean property for the title centered state
     */
    public ReadOnlyBooleanProperty titleCenteredProperty() {
        return titleCentered;
    }


    /**
     * Sets the height of the title bar.
     *
     * @param titleBarHeight the height to set for the title bar
     */
    public void setTitleBarHeight(int titleBarHeight) {
        this.titleBarHeight.set(titleBarHeight);
    }

    /**
     * Returns the height of the title bar.
     *
     * @return the height of the title bar
     */
    public int getTitleBarHeight() {
        return titleBarHeight.get();
    }

    /**
     * Returns an ReadOnlyIntegerProperty representing the height of the title bar.
     *
     * @return the ReadOnlyIntegerProperty for the title bar height
     */
    public ReadOnlyIntegerProperty titleBarHeightProperty() {
        return titleBarHeight;
    }


    /**
     * Handles the alignment of the title based on the specified center flag.
     *
     * @param center Flag indicating whether to center-align the title.
     */
    private void handleTitleAlignment(boolean center){
        if (center){
            HBox.setMargin(title, new Insets(0.0, 0.0, 0.0, 125));
            title.setAlignment(Pos.CENTER);
        }else {
            HBox.setMargin(title, new Insets(0.0, 0.0, 0.0, 5.0));
            title.setAlignment(Pos.CENTER_LEFT);
        }
    }

    /**
     * Processes the background and applies contrast styling to specific elements.
     * THIS METHOD IS VERY IMPORTANT, IT HANDLES THE SHAPES FILL COLORS FOR THE ACTION BUTTONS (MINIMIZE, MAX/RESTORE, CLOSE)
     * @param background the background to process
     */
     public void processBg(Background background){
        if (background!=null){
            if (background.getFills().size()>0){
                BackgroundFill fill=background.getFills().get(0);
                if ( fill!=null){
                    Color color= (Color) fill.getFill();
                    if (color!=null){
                        String hexColor=color.toString();
                        String contrastHexColor= ColorUtil.getContrast(hexColor);
                        HitSpot.defShapeColor=contrastHexColor;
                        actionBox.setDefaultShapesFill(contrastHexColor);
                        title.setStyle(String.format("-fx-text-fill: %s;",contrastHexColor));
                    }
                }
            }
        }
    }


    /**
     * Returns a list of HitSpots associated with the HitSpotManager.
     *
     * @return a list of HitSpots
     */
    public List<HitSpot> getHistSpots(){
        return actionBox.getHistSpots();
    }

}
